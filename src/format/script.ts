import { repeatChar, is, not } from '@utils/helpers';
import { NIL, NWL, WSP, cc as ch } from 'shared';
// import { StripEnd } from '@utils/regex';
import { parse } from '@parse/parser';
import { grammar } from '@shared/grammar';
import { Types } from 'types/shared';
import { assign } from '@utils/native';

// parse.beautify.script =

export function script () {

  /**
   * Reference to `rules.parsed` which is the
   * already parsed record generated by the lexer.
   */
  const { data, rules } = parse;

  const cache = { ...rules.script };

  rules.script = assign(rules.script, rules.json);

  /**
   * Semicolon
   */
  let semi = 0;

  /**
   * New keyword, ie: New
   *
   * This can probably be remove as it does nothing, it only holds
   * and integer level but that reference does not do anything...?
   */
  let news = 0;

  /**
   * External indexes
   */
  const exidx = {};

  /**
   * A constant variable reference to the lexer
   * name, ie: `script`
   */
  const lexer = 'script';

  /**
   * Holds reference to the source ending index or
   * the token ending index.
   */
  const b = (parse.ender < 1 || parse.ender > data.token.length) ? data.token.length : parse.ender + 1;

  /**
   * Levels
   *
   * Sets the white space value between the current token and the next token
   *
   * - `-20` value means no white space
   * - `-10` means to separate with a space
   * - `0` and above is the number of indentation to insert
   */
  const levels = (() => {

    /**
     * Will store the current level of indentation
     */
    let a: number = parse.start;

    /**
     * The indentation level as per `indentLevel` which is
     * an internal reference.
     */
    let indent: number = rules.indentLevel;

    /**
     * If in comments before any code
     */
    let notcomment: boolean = false;

    /**
     * Remembers the list status of the most recently closed block
     */
    let lastlist: boolean = false;

    /**
     * Stands for "current type"
     */
    let ctype: string = NIL; // ctype stands for "current type"

    /**
     * Stands for "current token"
     */
    let ctoke: string = NIL;

    /**
     * Stands for "last type"
     */
    let ltype: Types = data.types[0]; // ltype stands for "last type"

    /**
     * Stands for "last token"
     */
    let ltoke: string = data.token[0];

    /**
     * Index in current scope of last `var`, `let`, or `const` keyword
     */
    const vindex: number[] = [ -1 ];

    /**
     * Stores comma status of current block
     */
    const commas: boolean[] = [];

    /**
     * The current level
     */
    const level = (parse.start > 0) ? Array(parse.start).fill(0, 0, parse.start) : [];

    /**
     * Used to identify ternary statments
     */
    const ternary: number[] = [];

    /**
     * Stores token indexes where extra indentation occurs from ternaries
     * and broken method chains
     */
    const extraindent = [ [] ];

    /**
     * Array where a method break has occurred
     */
    const arrbreak: boolean[] = [];

    /**
     * Attempt to identify object destructuring
     */
    const destruct: boolean[] = [];

    /**
     * Counts items in destructured lists
     */
    const itemcount: number[] = [];

    /**
     * Are you in a list right now?
     */
    const assignlist: boolean[] = [ false ];
    const wordlist = [];
    const count = [];

    function comment () {

      destructfix(false, false);

      const ind = rules.script.commentIndent === true ? indent : 0;

      if (notcomment === false && (/\/\u002a\s*global\s/).test(data.token[a])) {

        const glist = data.token[a]
          .replace(/\/\u002a\s*global\s+/, NIL)
          .replace(/\s*\u002a\/$/, NIL)
          .split(',');

        let aa = glist.length;

        do {

          aa = aa - 1;
          glist[aa] = glist[aa].replace(/\s+/g, NIL);

          if (glist[aa] !== NIL) parse.scopes.push([ glist[aa], -1 ]);

        } while (aa > 0);
      }

      if (data.types[a - 1] === 'comment' || data.types[a + 1] === 'comment') {

        level[a - 1] = ind;

      } else if (data.lines[a] < 2) {

        let aa = a + 1;

        if (data.types[aa] === 'comment') {
          do aa = aa + 1;
          while (aa < b && data.types[aa] === 'comment');
        }

        if (a < b - 1 && data.stack[aa] !== 'block' && (is(data.token[aa], ch.LCB) || data.token[aa] === 'x{')) {

          let bb = parse.scopes.length;

          data.begin.splice(a, 0, data.begin[aa]);
          data.ender.splice(a, 0, data.ender[aa]);
          data.lexer.splice(a, 0, data.lexer[aa]);
          data.lines.splice(a, 0, data.lines[aa]);
          data.stack.splice(a, 0, data.stack[aa]);
          data.token.splice(a, 0, data.token[aa]);
          data.types.splice(a, 0, data.types[aa]);

          if (bb > 0) {
            do {
              bb = bb - 1;
              if (parse.scopes[bb][1] === aa) {
                parse.scopes[bb][1] = a;
              } else if (parse.scopes[bb][1] < a) {
                break;
              }
            } while (bb > 0);
          }

          aa = aa + 1;

          data.begin.splice(aa, 1);
          data.ender.splice(aa, 1);
          data.lexer.splice(aa, 1);
          data.lines.splice(aa, 1);
          data.stack.splice(aa, 1);
          data.token.splice(aa, 1);
          data.types.splice(aa, 1);

          bb = a + 1;

          do {
            data.begin[bb] = a;
            data.stack[bb] = data.stack[aa];
            bb = bb + 1;
          } while (bb < aa);

          bb = bb + 1;

          do {

            if (data.begin[bb] === data.begin[aa]) {
              data.begin[bb] = a;
              if (data.types[bb] === 'end') break;
            }

            bb = bb + 1;
          } while (bb < b - 1);

          data.begin[aa] = a;

          a = a - 1;

        } else {

          level[a - 1] = -10;

          if (data.stack[a] === 'paren' || data.stack[a] === 'method') {
            level.push(indent + 2);
          } else {
            level.push(indent);
          }

          if (rules.script.commentIndent === true && level[a] > -1 && data.lines[a] < 3) {
            data.lines[a] = 3;
          }
        }

        if (data.types[a + 1] !== 'comment') notcomment = true;

        return;

      } else if (is(data.token[a - 1], ch.COM)) {

        level[a - 1] = ind;

      } else if (
        is(ltoke, ch.EQS) &&
        data.types[a - 1] !== 'comment' &&
        /^\/\*{2}\s*@[A-Za-z_]+/.test(ctoke) === true
      ) {

        level[a - 1] = -10;

      } else if (is(ltoke, ch.LCB) && data.types[a - 1] !== 'comment' && data.lines[0] < 2) {

        // HOT PATCH
        //
        // Indents comments which contain a newline
        // or if the stack is function we don't want to inline
        // the comment, instead we need a newline
        //
        if (data.stack[a] === 'function') {
          level[a - 1] = ind;
        } else {
          level[a - 1] = /\n/.test(ctoke) ? ind : -10;
        }

      } else {

        level[a - 1] = ind;

      }

      if (data.types[a + 1] !== 'comment') notcomment = true;

      if (is(data.token[data.begin[a]], ch.LPR)) {
        level.push(indent + 1);
      } else {
        level.push(indent);
      }

      if (level[a] > -1 && data.lines[a] < 3) {

        // HOT PATCH
        //
        // When comment lines follow comment lines we don't
        // want indentation between them, this fixes that.
        //
        if (data.types[a - 1] === 'comment' && ctoke.startsWith('//')) {
          data.lines[a] = 2;
        } else {
          data.lines[a] = 3;
        }

      }

      // HOT PATCH
      //
      // We exposed the commentNewline rule to the script options
      // this function controls the newline logic imposed on all
      // block type comments.
      //
      if (
        rules.script.commentNewline === true &&
        ctoke.startsWith('//') === false &&
        data.lines[a] >= 3
      ) {

        data.lines[a] = 2;
      }

    };

    function destructfix (listFix: boolean, override: boolean) {

      // listfix  - at the end of a list correct the containing list override - to
      // break arrays with more than 4 items into a vertical list
      let c = a - 1;
      let d = (listFix === true) ? 0 : 1;

      const ei = (extraindent[extraindent.length - 1] === undefined)
        ? []
        : extraindent[extraindent.length - 1];

      const arrayCheck = (
        override === false &&
        data.stack[a] === 'array' &&
        listFix === true &&
        not(ctoke, ch.LSB)
      );

      if (
        destruct[destruct.length - 1] === false || (
          data.stack[a] === 'array' &&
          rules.script.arrayFormat === 'inline'
        ) || (
          data.stack[a] === 'object' &&
          rules.script.objectIndent === 'inline'
        )
      ) {
        return;
      }

      destruct[destruct.length - 1] = false;

      do {
        if (data.types[c] === 'end') {
          d = d + 1;
        } else if (data.types[c] === 'start') {
          d = d - 1;
        }

        if (data.stack[c] === 'global') break;

        if (d === 0) {

          if (
            data.stack[a] === 'class' ||
            data.stack[a] === 'map' || (
              arrayCheck === false && (
                (
                  listFix === false &&
                  data.token[c] !== '(' &&
                  data.token[c] !== 'x('
                ) || (
                  listFix === true &&
                  is(data.token[c], ch.COM)
                )
              )
            )
          ) {

            if (data.types[c + 1] === 'liquid_start') {

              if (data.lines[c] < 1) {
                level[c] = -20;
              } else {
                level[c] = indent - 1;
              }

            } else if (ei.length > 0 && ei[ei.length - 1] > -1) {
              level[c] = indent - 1;
            } else {
              level[c] = indent;
            }

          } else if (data.stack[a] === 'array' && data.types[a] === 'operator') {

            if (is(data.token[c], ch.COM)) level[c] = indent;
            if (c === data.begin[a]) break;

          }

          if (listFix === false) break;

        }

        if (d < 0) {

          if (
            data.types[c + 1] === 'liquid_start' ||
            data.types[c + 1] === 'template_string_start'
          ) {

            if (data.lines[c] < 1) {
              level[c] = -20;
            } else {
              level[c] = indent - 1;
            }

          } else if (ei.length > 0 && ei[ei.length - 1] > -1) {
            level[c] = indent - 1;
          } else {
            level[c] = indent;
          }
          break;
        }

        c = c - 1;

      } while (c > -1);

    };

    function end () {

      /**
       * Extra Indentations
       */
      const ei = extraindent[extraindent.length - 1] === undefined
        ? []
        : extraindent[extraindent.length - 1];

      const markuplist = () => {

        let aa = a;
        let markup = false;

        const begin = data.begin[aa];

        do {

          aa = aa - 1;

          if (data.lexer[aa] === 'markup') {
            markup = true;
            break;
          }

          if (data.begin[aa] !== begin) aa = data.begin[aa];

        } while (aa > begin);

        if (markup === true) {

          aa = a;

          do {
            aa = aa - 1;
            if (data.begin[aa] !== begin) {
              aa = data.begin[aa];
            } else if (is(data.token[aa], ch.COM)) {
              level[aa] = indent + 1;
            }
          } while (aa > begin);

          level[begin] = indent + 1;
          level[a - 1] = indent;

        } else {
          level[a - 1] = -20;
        }
      };

      if (
        is(ctoke, ch.RPR) &&
        is(data.token[a + 1], ch.DOT) &&
        not(data.token[ei[0]], ch.COL) &&
        ei[ei.length - 1] > -1
      ) {

        let c = data.begin[a];
        let d = false;
        let e = false;

        do c = c - 1;
        while (c > 0 && level[c] < -9);

        d = (level[c] === indent);
        c = a + 1;

        do {

          c = c + 1;

          if (is(data.token[c], ch.LCB)) {
            e = true;
            break;
          }

          if (
            data.begin[c] === data.begin[a + 1] && (
              data.types[c] === 'separator' ||
              data.types[c] === 'end'
            )
          ) {
            break;
          }

        } while (c < b);

        if (d === false && e === true && extraindent.length > 1) {
          extraindent[extraindent.length - 2].push(data.begin[a]);
          indent = indent + 1;
        }
      }

      if (ltype !== 'separator') fixchain();

      if (is(data.token[a + 1], ch.COL) && (
        data.stack[a] === 'object' ||
        data.stack[a] === 'array'
      )) {

        destructfix(true, false);

      }

      if (is(data.token[data.begin[a] - 1], ch.COM) && (
        is(data.token[a + 1], ch.RCB) ||
        is(data.token[a + 1], ch.RSB)
      ) && (
        data.stack[a] === 'object' ||
        data.stack[a] === 'array'
      )) {

        destructfix(true, false);

      }

      if (data.stack[a] !== 'attribute') {

        if (not(ctoke, ch.RPR) &&
          ctoke !== 'x)' && (
          data.lexer[a - 1] !== 'markup' || (
            data.lexer[a - 1] === 'markup' &&
            data.token[a - 2] !== 'return'
          )
        )) {

          indent = indent - 1;
        }

        if (
          is(ctoke, ch.RCB) &&
          data.stack[a] === 'switch' &&
          rules.script.noCaseIndent === false
        ) {

          indent = indent - 1;
        }
      }

      if (is(ctoke, ch.RCB) || ctoke === 'x}') {

        if (data.types[a - 1] !== 'comment' &&
          ltoke !== '{' &&
          ltoke !== 'x{' &&
          ltype !== 'end' &&
          ltype !== 'string' &&
          ltype !== 'number' &&
          ltype !== 'separator' &&
          ltoke !== '++' &&
          ltoke !== '--' && (
          a < 2 ||
            data.token[a - 2] !== ';' ||
            data.token[a - 2] !== 'x;' ||
            ltoke === 'break' ||
            ltoke === 'return'
        )) {

          let c = a - 1;
          let assign = false;

          const begin = data.begin[a];
          const listlen = commas.length;

          do {

            if (data.begin[c] === begin) {

              if (is(data.token[c], ch.EQS) || is(data.token[c], ch.SEM) || data.token[c] === 'x;') {
                assign = true;
              }

              if (is(data.token[c], ch.DOT) && level[c - 1] > -1) {

                // setting destruct is necessary to prevent a rule below
                destruct[destruct.length - 1] = false;

                level[begin] = indent + 1;
                level[a - 1] = indent;

                break;
              }

              if (
                c > 0 &&
                data.token[c] === 'return' && (
                  data.token[c - 1] === ')' ||
                  data.token[c - 1] === 'x)' ||
                  data.token[c - 1] === '{' ||
                  data.token[c - 1] === 'x{' ||
                  data.token[c - 1] === '}' ||
                  data.token[c - 1] === 'x}' ||
                  data.token[c - 1] === ';' ||
                  data.token[c - 1] === 'x;'
                )
              ) {

                indent = indent - 1;
                level[a - 1] = indent;
                break;
              }

              if (
                (
                  is(data.token[c], ch.COL) &&
                  ternary.length === 0
                ) || (
                  is(data.token[c], ch.COM) &&
                  assign === false
                )
              ) {
                break;
              }

              if ((
                c === 0 ||
                data.token[c - 1] === '{' ||
                data.token[c - 1] === 'x{'
              ) ||
                data.token[c] === 'for' ||
                data.token[c] === 'if' ||
                data.token[c] === 'do' ||
                data.token[c] === 'function' ||
                data.token[c] === 'while' ||
                data.token[c] === 'var' ||
                data.token[c] === 'let' ||
                data.token[c] === 'const' ||
                data.token[c] === 'with'
              ) {

                if (
                  commas[listlen - 1] === false &&
                  listlen > 1 && (
                    a === b - 1 || (
                      data.token[a + 1] !== ')' &&
                      data.token[a + 1] !== 'x)'
                    )
                  ) &&
                  data.stack[a] !== 'object'
                ) {
                  indent = indent - 1;
                }

                break;
              }

            } else {

              c = data.begin[c];
            }

            c = c - 1;
          } while (c > begin);

        }

        vindex.pop();
      }

      if (rules.script.bracePadding === false && ctoke !== '}' && ltype !== 'markup') {
        level[a - 1] = -20;
      }

      if (
        rules.script.bracePadding === true &&
        ltype !== 'start' &&
        ltoke !== ';' &&
        (
          level[data.begin[a]] < -9 ||
          destruct[destruct.length - 1] === true
        )
      ) {

        level[data.begin[a]] = -10;
        level[a - 1] = -10;
        level.push(-20);

      } else if (data.stack[a] === 'attribute') {

        level[a - 1] = -20;
        level.push(indent);

      } else if (
        data.stack[a] === 'array' && (
          ei.length > 0 ||
          arrbreak[arrbreak.length - 1] === true
        )
      ) {

        endExtraInd();

        destruct[destruct.length - 1] = false;
        level[data.begin[a]] = indent + 1;
        level[a - 1] = indent;
        level.push(-20);

      } else if (
        (
          data.stack[a] === 'object' || (
            data.begin[a] === 0 &&
            is(ctoke, ch.RCB)
          )
        ) &&
        ei.length > 0
      ) {

        endExtraInd();

        destruct[destruct.length - 1] = false;
        level[data.begin[a]] = indent + 1;
        level[a - 1] = indent;
        level.push(-20);

      } else if (ctoke === ')' || ctoke === 'x)') {

        const countx = (ctoke === ')' && not(ltoke, ch.LPR) && count.length > 0) ? count.pop() + 1 : 0;
        const countif = (data.token[data.begin[a] - 1] === 'if') ? (() => {

          let bb = a;

          do {

            bb = bb - 1;

            if (data.token[bb] === ')' && level[bb - 1] > -1) return countx;

          } while (bb > data.begin[a]);

          return countx + 5;

        })() : countx;

        if (
          countx > 0 && (
            rules.language !== 'jsx' || (
              rules.language === 'jsx' &&
              data.token[data.begin[a] - 1] !== 'render'
            )
          )
        ) {

          const wrap = rules.wrap;
          const begin = data.begin[a];
          const len = count.length;

          let aa = a - 2;

          if (countif > wrap) {

            level[data.begin[a]] = indent + 1;
            level[a - 1] = indent;

            do {

              if (data.begin[aa] === begin) {

                if (data.token[aa] === '&&' || data.token[aa] === '||') {

                  level[aa] = indent + 1;

                } else if (
                  level[aa] > -1 &&
                  data.types[aa] !== 'comment' &&
                  data.token[aa + 1] !== '.'
                ) {
                  level[aa] = level[aa] + 1;
                }

              } else if (level[aa] > -1 && data.token[aa + 1] !== '.') {
                level[aa] = level[aa] + 1;
              }

              aa = aa - 1;

            } while (aa > begin);

          } else if (len > 0) {

            count[len - 1] = count[len - 1] + countx;
          }

        } else if (
          ctoke === ')' &&
          a > data.begin[a] + 2 &&
          data.lexer[data.begin[a] + 1] === lexer &&
          data.token[data.begin[a] + 1] !== 'function'
        ) {

          const open = (data.begin[a] < 0) ? 0 : data.begin[a];
          const wrap = rules.wrap;
          const exl = ei.length;

          let len = 0;
          let aa = 0;
          let short = 0;
          let first = 0;
          let inc = 0;
          let comma = false;
          let array = false;
          let ind = (indent + 1);
          let ready = false;
          let mark = false;
          let tern = false;

          if (level[open] < -9) {

            aa = open;

            do { aa = aa + 1; } while (aa < a && level[aa] < -9);

            first = aa;

            do {

              len = len + data.token[aa].length;

              if (level[aa] === -10) len = len + 1;

              if (
                data.token[aa] === '(' &&
                short > 0 &&
                short < wrap - 1 &&
                first === a
              ) {
                short = -1;
              }

              if (data.token[aa] === ')') {
                inc = inc - 1;
              } else if (data.token[aa] === '(') {
                inc = inc + 1;
              }

              if (aa === open && inc > 0) short = len;

              aa = aa - 1;

            } while (aa > open && level[aa] < -9);

            if (data.token[aa + 1] === '.') ind = level[aa] + 1;

            if (
              len > wrap - 1 &&
              wrap > 0 &&
              not(ltoke, ch.LPR) &&
              short !== -1 && destruct[destruct.length - 2] === false
            ) {

              if (
                (
                  data.token[open - 1] === 'if' &&
                  commas[commas.length - 1] === true
                ) ||
                data.token[open - 1] !== 'if'
              ) {

                level[open] = ind;

                if (data.token[open - 1] === 'for') {

                  aa = open;

                  do {

                    aa = aa + 1;

                    if (is(data.token[aa], ch.SEM) && data.begin[
                      aa] === open) {
                      level[aa] = ind;
                    }

                  } while (aa < a);
                }
              }
            }
          }

          aa = a;
          len = 0;

          do {

            aa = aa - 1;

            if (data.stack[aa] === 'function') {

              aa = data.begin[aa];

            } else if (data.begin[aa] === open) {

              if (data.token[aa] === '?') {

                tern = true;
              } else if (is(data.token[aa], ch.COM) && comma === false) {
                comma = true;

                if (len >= wrap && wrap > 0) ready = true;

              } else if (data.types[aa] === 'markup' && mark === false) {
                mark = true;
              }

              if (level[aa] > -9 && data.token[aa] !== ',' && data.types[aa] !== 'markup') {
                len = 0;
              } else {

                if (level[aa] === -10) len = len + 1;

                len = len + data.token[aa].length;

                if (len >= wrap && wrap > 0 && (comma === true || mark === true)) {
                  ready = true;
                }

              }

            } else {

              if (level[aa] > -9) {
                len = 0;
              } else {

                len = len + data.token[aa].length;
                if (len >= wrap && wrap > 0 && (comma === true || mark === true)) {
                  ready = true;
                }
              }
            }

          } while (aa > open && ready === false);

          if (
            comma === false &&
            data.token[data.begin[a] + 1].charAt(0) === '`'
          ) {
            level[data.begin[a]] = -20;
            level[a - 1] = -20;
          } else if (
            (
              (
                comma === true ||
                mark === true
              ) &&
              len >= wrap &&
              wrap > 0
            ) || level[open] > -9
          ) {

            if (tern === true) {

              ind = level[open];

              if (data.token[open - 1] === '[') {

                aa = a;

                do {
                  aa = aa + 1;
                  if (
                    data.types[aa] === 'end' ||
                    is(data.token[aa], ch.COM) ||
                    is(data.token[aa], ch.SEM)
                  ) {
                    break;
                  }
                } while (aa < b);

                if (data.token[aa] === ']') {
                  ind = ind - 1;
                  array = true;
                }
              }

            } else if (exl > 0 && ei[exl - 1] > aa) {
              ind = ind - exl;
            }

            destruct[destruct.length - 1] = false;
            aa = a;

            do {
              aa = aa - 1;

              if (data.begin[aa] === open) {

                if (
                  data.token[aa].indexOf('=') > -1 &&
                  data.types[aa] === 'operator' &&
                  data.token[aa].indexOf('!') < 0 &&
                  data.token[aa].indexOf('==') < 0 &&
                  data.token[aa] !== '<=' && data.token[aa].indexOf('>') < 0
                ) {

                  len = aa;

                  do {
                    len = len - 1;
                    if (
                      data.begin[len] === open && (
                        data.token[len] === ';' ||
                        data.token[len] === ',' ||
                        len === open
                      )
                    ) {
                      break;
                    }

                  } while (len > open);

                } else if (is(data.token[aa], ch.COM)) {

                  level[aa] = ind;

                } else if (
                  level[aa] > -9 &&
                  array === false && (
                    data.token[open - 1] !== 'for' ||
                    data.token[aa + 1] === '?' ||
                    data.token[aa + 1] === ':'
                  ) && (
                    data.token[data.begin[a]] !== '(' ||
                    data.token[aa] !== '+'
                  )
                ) {
                  level[aa] = level[aa] + 1;
                }

              } else if (level[aa] > -9 && array === false) {
                level[aa] = level[aa] + 1;
              }

            } while (aa > open);

            level[open] = ind;
            level[a - 1] = ind - 1;

          } else {
            level[a - 1] = -20;
          }

          if (data.token[data.begin[a] - 1] === '+' && level[data.begin[a]] > -9) {
            level[data.begin[a] - 1] = -10;
          }

        } else if (rules.language === 'jsx') {
          markuplist();
        } else {
          level[a - 1] = -20;
        }

        level.push(-20);

      } else if (destruct[destruct.length - 1] === true) {

        if (
          ctoke === ']' &&
          data.begin[a] - 1 > 0 &&
          data.token[data.begin[data.begin[a] - 1]] === '['
        ) {
          destruct[destruct.length - 2] = false;
        }

        if (data.begin[a] < level.length) level[data.begin[a]] = -20;

        if (rules.language === 'jsx') {
          markuplist();
        } else if (ctoke === ']' && level[data.begin[a]] > -1) {
          level[a - 1] = level[data.begin[a]] - 1;
        } else {
          level[a - 1] = -20;
        }

        level.push(-20);

      } else if (
        data.types[a - 1] === 'comment' &&
        data.token[a - 1].substring(0, 2) === '//'
      ) {

        if (data.token[a - 2] === 'x}') level[a - 3] = indent + 1;

        level[a - 1] = indent;
        level.push(-20);

      } else if (
        data.types[a - 1] !== 'comment' && (
          (
            is(ltoke, ch.LCB) &&
            is(ctoke, ch.RCB)
          ) || (
            is(ltoke, ch.LSB) &&
            ctoke === ']'
          )
        )
      ) {

        level[a - 1] = -20;
        level.push(-20);

      } else if (ctoke === ']') {

        if (
          (
            commas[commas.length - 1] === true &&
            destruct[destruct.length - 1] === false &&
            rules.script.arrayFormat !== 'inline'
          ) || (
            is(ltoke, ch.RSB) && level[a - 2] === indent + 1
          )
        ) {

          level[a - 1] = indent;
          level[data.begin[a]] = indent + 1;

        } else if (level[a - 1] === -10) {
          level[a - 1] = -20;
        }

        if (data.token[data.begin[a] + 1] === 'function') {

          level[a - 1] = indent;

        } else if (commas[commas.length - 1] === false) {

          if (is(ltoke, ch.RCB) || ltoke === 'x}') level[a - 1] = indent;

          let c = a - 1;
          let d = 1;

          do {

            if (data.token[c] === ']') d = d + 1;
            if (data.token[c] === '[') {

              d = d - 1;

              if (d === 0) {

                if (
                  c > 0 && (
                    data.token[c + 1] === '{' ||
                    data.token[c + 1] === 'x{' ||
                    data.token[c + 1] === '['
                  )
                ) {

                  level[c] = indent + 1;
                  break;
                }

                if (data.token[c + 1] !== '[' || lastlist === false) {
                  level[c] = -20;
                  break;
                }

                break;
              }
            }

            if (d === 1 && data.token[c] === '+' && level[c] > 1) {
              level[c] = level[c] - 1;
            }

            c = c - 1;

          } while (c > -1);

        } else if (rules.language === 'jsx') {
          markuplist();
        }

        if (rules.script.arrayFormat === 'inline') {

          let c = a;
          const begin = data.begin[a];

          do {

            c = c - 1;
            if (data.types[c] === 'end') break;

          } while (c > begin);

          if (c > begin) {
            level[data.begin[a]] = indent + 1;
            level[a - 1] = indent;
          } else {
            level[data.begin[a]] = -20;
            level[a - 1] = -20;
          }

        } else if (level[data.begin[a]] > -1) {

          level[a - 1] = level[data.begin[a]] - 1;
        }

        level.push(-20);

      } else if (
        is(ctoke, ch.RCB) ||
        ctoke === 'x}' ||
        commas[commas.length - 1] === true
      ) {

        if (
          is(ctoke, ch.RCB) &&
          ltoke === 'x}' &&
          data.token[a + 1] === 'else'
        ) {

          level[a - 2] = indent + 2;
          level.push(-20);

        } else {

          level.push(indent);

        }

        level[a - 1] = indent;

      } else {
        level.push(-20);
      }

      if (data.types[a - 1] === 'comment') level[a - 1] = indent;

      endExtraInd();

      lastlist = commas[commas.length - 1];

      commas.pop();
      extraindent.pop();
      arrbreak.pop();
      itemcount.pop();
      wordlist.pop();
      destruct.pop();
      assignlist.pop();

    };

    function endExtraInd () {

      let c = 0;
      const ei = extraindent[extraindent.length - 1];

      if (ei === undefined) return;

      c = ei.length - 1;

      if (
        c < 1 &&
        ei[c] < 0 && (
          is(ctoke, ch.SEM) ||
          ctoke === 'x;' ||
          ctoke === ')' ||
          ctoke === 'x)' ||
          is(ctoke, ch.RCB) ||
          ctoke === 'x}'
        )
      ) {
        ei.pop();
        return;
      }

      if (c < 0 || ei[c] < 0) return;

      if (ctoke === ':') {

        if (data.token[ei[c]] !== '?') {

          do {
            ei.pop();
            c = c - 1;
            indent = indent - 1;
          } while (c > -1 && ei[c] > -1 && data.token[ei[c]] !== '?');
        }

        ei[c] = a;
        level[a - 1] = indent;
      } else {

        do {
          ei.pop();
          c = c - 1;
          indent = indent - 1;
        } while (c > -1 && ei[c] > -1);
      }

      if ((data.stack[a] === 'array' || ctoke === ',') && ei.length < 1) ei.push(-1);

    };

    function external () {

      const skip = a;

      do {

        if (data.lexer[a + 1] === lexer && data.begin[a + 1] < skip) break;

        if (
          data.token[skip - 1] === 'return' &&
          data.types[a] === 'end' &&
          data.begin[a] === skip
        ) break;

        level.push(0);

        a = a + 1;

      } while (a < b);

      // console.log(data.token[skip], data.types[skip], data.lexer[a]);
      exidx[skip] = a;
      level.push(indent - 1);

    };

    function fixchain () {

      let bb = a - 1;

      const cc = data.begin[a];

      if (indent < 1) return;

      do {

        if (cc !== data.begin[bb]) {
          bb = data.begin[bb];
        } else {

          if (data.types[bb] === 'separator' || data.types[bb] === 'operator') {

            if (data.token[bb] === '.' && level[bb - 1] > 0) {
              if (data.token[cc - 1] === 'if') {
                indent = indent - 2;
              } else {
                indent = indent - 1;
              }
            }

            break;
          }
        }

        bb = bb - 1;

      } while (bb > 0 && bb > cc);
    };

    function markup () {

      if (
        (
          data.token[a + 1] !== ',' &&
          ctoke.indexOf('/>') !== ctoke.length - 2
        ) || (
          data.token[a + 1] === ',' &&
          data.token[data.begin[a] - 3] !== 'React'
        )
      ) {
        destructfix(false, false);
      }

      if (ltoke === 'return' || ltoke === '?' || ltoke === ':') {
        level[a - 1] = -10;
        level.push(-20);
      } else if (
        ltype === 'start' || (
          data.token[a - 2] === 'return' &&
          data.stack[a - 1] === 'method'
        )
      ) {

        level.push(indent);
      } else {
        level.push(-20);
      }

    };

    function operator () {

      const ei = (extraindent[extraindent.length - 1] === undefined)
        ? []
        : extraindent[extraindent.length - 1];

      function opWrap () {

        const aa = data.token[a + 1];

        let line = 0;
        let next = 0;
        let c = a;
        let ind = (ctoke === '+') ? indent + 2 : indent;
        let meth = 0;

        if (rules.wrap < 1) {
          level.push(-10);
          return;
        }

        do {

          c = c - 1;

          if (is(data.token[data.begin[a]], ch.LPR)) {
            if (c === data.begin[a]) {
              meth = line;
            }

            if (
              is(data.token[c], ch.COM) &&
              data.begin[c] === data.begin[a] &&
              commas[commas.length - 1] === true) {
              break;
            }
          }

          if (line > rules.wrap - 1) break;
          if (level[c] > -9) break;

          if (
            data.types[c] === 'operator' &&
            data.token[c] !== '=' &&
            data.token[c] !== '+' &&
            data.begin[c] === data.begin[a]
          ) {
            break;
          }

          line = line + data.token[c].length;

          if (
            c === data.begin[a] &&
            data.token[c] === '[' &&
            line < rules.wrap - 1
          ) {
            break;
          }

          if (data.token[c] === '.' && level[c] > -9) break;
          if (level[c] === -10) line = line + 1;

        } while (c > 0);

        if (meth > 0) meth = meth + aa.length;

        line = line + aa.length;
        next = c;

        if (line > rules.wrap - 1 && level[c] < -9) {
          do { next = next - 1; } while (next > 0 && level[next] < -9);
        }

        if (data.token[next + 1] === '.' && data.begin[a] <= data.begin[next]) {
          ind = ind + 1;
        } else if (data.types[next] === 'operator') {
          ind = level[next];
        }

        next = aa.length;

        if (line + next < rules.wrap) {
          level.push(-10);
          return;
        }

        if (
          is(data.token[data.begin[a]], ch.LPR) && (
            data.token[ei[0]] === ':' ||
            data.token[ei[0]] === '?'
          )
        ) {
          ind = indent + 3;
        } else if (data.stack[a] === 'method') {

          level[data.begin[a]] = indent;

          if (commas[commas.length - 1] === true) {
            ind = indent + 3;
          } else {
            ind = indent + 1;
          }

        } else if (
          data.stack[a] === 'object' ||
          data.stack[a] === 'array'
        ) {
          destructfix(true, false);
        }

        if (
          data.token[c] === 'var' ||
          data.token[c] === 'let' ||
          data.token[c] === 'const'
        ) {

          line = line - (rules.indentSize * rules.indentChar.length * 2);
        }

        if (meth > 0) {
          c = rules.wrap - meth;
        } else {
          c = rules.wrap - line;
        }

        if (c > 0 && c < 5) {

          level.push(ind);

          if (
            data.token[a].charAt(0) === '"' ||
            data.token[a].charAt(0) === "'"
          ) {
            a = a + 1;
            level.push(-10);
          }

          return;
        }

        if (data.token[data.begin[a]] !== '(' || meth > rules.wrap - 1 || meth === 0) {

          if (meth > 0) line = meth;

          if (
            line - aa.length < rules.wrap - 1 && (
              aa.charAt(0) === '"' ||
              aa.charAt(0) === "'"
            )
          ) {

            a = a + 1;
            line = line + 3;

            if (line - aa.length > rules.wrap - 4) {
              level.push(ind);
              return;
            }

            level.push(-10);
            return;

          }

          level.push(ind);
          return;
        }

        level.push(-10);

      };

      fixchain();

      if (
        ei.length > 0 &&
        ei[ei.length - 1] > -1 &&
        data.stack[a] === 'array'
      ) {
        arrbreak[arrbreak.length - 1] = true;
      }

      if (ctoke !== ':') {

        if (
          data.token[data.begin[a]] !== '(' &&
          data.token[data.begin[a]] !== 'x(' &&
          destruct.length > 0
        ) {
          destructfix(true, false);
        }

        if (
          ctoke !== '?' &&
          data.token[ei[ei.length - 1]] === '.'
        ) {

          let e = 0;
          let c = a;

          const d = data.begin[c];

          do {

            if (data.begin[c] === d) {

              if (
                data.token[c + 1] === '{' ||
                data.token[c + 1] === '[' ||
                data.token[c] === 'function'
              ) {
                break;
              }

              if (
                is(data.token[c], ch.COM) ||
                is(data.token[c], ch.SEM) ||
                data.types[c] === 'end' ||
                is(data.token[c], ch.COL)
              ) {
                ei.pop();
                indent = indent - 1;
                break;
              }

              if (data.token[c] === '?' || is(data.token[c], ch.COL)) {
                if (data.token[ei[ei.length - 1]] === '.' && e < 2) ei[ei.length - 1] = d + 1;
                break;
              }

              if (data.token[c] === '.') e = e + 1;

            }

            c = c + 1;

          } while (c < b);
        }
      }

      if (ctoke === '!' || ctoke === '...') {
        if (is(ltoke, ch.RCB) || ltoke === 'x}') level[a - 1] = indent;
        level.push(-20);
        return;
      }

      if (ltoke === ';' || ltoke === 'x;') {
        if (data.token[data.begin[a] - 1] !== 'for') level[a - 1] = indent;
        level.push(-20);
        return;
      }

      if (ctoke === '*') {

        if (ltoke === 'function' || ltoke === 'yield') {
          level[a - 1] = -20;
        } else {
          level[a - 1] = -10;
        }

        level.push(-10);
        return;
      }

      if (ctoke === '?') {

        if (
          data.lines[a] === 0 &&
          data.types[a - 2] === 'word' &&
          data.token[a - 2] !== 'return' &&
          data.token[a - 2] !== 'in' &&
          data.token[a - 2] !== 'instanceof' &&
          data.token[a - 2] !== 'typeof' && (
            ltype === 'reference' ||
            ltype === 'word'
          )
        ) {

          if (
            data.types[a + 1] === 'word' ||
            data.types[a + 1] === 'reference' || (
              (
                is(data.token[a + 1], ch.LPR) ||
                data.token[a + 1] === 'x('
              ) &&
              data.token[a - 2] === 'new'
            )
          ) {

            level[a - 1] = -20;

            if (
              data.types[a + 1] === 'word' ||
              data.types[a + 1] === 'reference') {
              level.push(-10);
              return;
            }

            level.push(-20);
            return;
          }
        }

        if (data.token[a + 1] === ':') {
          level[a - 1] = -20;
          level.push(-20);
          return;
        }

        ternary.push(a);

        if (rules.script.ternaryLine === true) {
          level[a - 1] = -10;
        } else {

          let c = a - 1;

          do { c = c - 1; } while (c > -1 && level[c] < -9);

          ei.push(a);
          indent = indent + 1;

          if (level[c] === indent && data.token[c + 1] !== ':') {
            indent = indent + 1;
            ei.push(a);
          }

          level[a - 1] = indent;

          if (is(data.token[data.begin[a]], ch.LPR) && (ei.length < 2 || ei[0] === ei[1])) {

            destruct[destruct.length - 1] = false;

            if (a - 2 === data.begin[a]) {
              level[data.begin[a]] = indent - 1;
            } else {
              level[data.begin[a]] = indent;
            }

            c = a - 2;

            do {

              if (data.types[c] === 'end' && level[c - 1] > -1) break;
              if (level[c] > -1) level[c] = level[c] + 1;

              c = c - 1;

            } while (c > data.begin[a]);
          }
        }

        level.push(-10);
        return;
      }

      if (ctoke === ':') {
        if (
          data.stack[a] === 'map' ||
          data.types[a + 1] === 'type' ||
          data.types[a + 1] === 'type_start'
        ) {
          level[a - 1] = -20;
          level.push(-10);
          return;
        }

        if (
          ternary.length > 0 &&
          data.begin[ternary[ternary.length - 1]] === data.begin[a]
        ) {

          let c = a;
          const d = data.begin[a];

          do {

            c = c - 1;

            if (data.begin[c] === d) {

              if (is(data.token[c], ch.COM) || is(data.token[c], ch.SEM)) {
                level[a - 1] = -20;
                break;
              }

              if (data.token[c] === '?') {
                ternary.pop();
                endExtraInd();

                if (rules.script.ternaryLine === true) level[a - 1] = -10;

                level.push(-10);
                return;
              }

            } else if (data.types[c] === 'end') {
              c = data.begin[c];
            }

          } while (c > d);
        }

        if (
          data.token[a - 2] === 'where' &&
          data.stack[a - 2] === data.stack[a]
        ) {
          level[a - 1] = -10;
          level.push(-10);
          return;
        }

        if (
          ltype === 'reference' &&
          data.token[data.begin[a]] !== '(' &&
          data.token[data.begin[a]] !== 'x('
        ) {
          level[a - 1] = -20;
          level.push(-10);
          return;
        }

        if (
          (
            is(ltoke, ch.RPR) ||
            ltoke === 'x)'
          ) && data.token[data.begin[a - 1] - 2] === 'function'
        ) {
          level[a - 1] = -20;
          level.push(-10);
          return;
        }

        if (data.stack[a] === 'attribute') {
          level[a - 1] = -20;
          level.push(-10);
          return;
        }

        if (
          data.token[data.begin[a]] !== '(' &&
          data.token[data.begin[a]] !== 'x(' && (
            ltype === 'reference' ||
            is(ltoke, ch.RPR) ||
            is(ltoke, ch.RSB) ||
            ltoke === '?'
          ) && (
            data.stack[a] === 'map' ||
            data.stack[a] === 'class' ||
            data.types[a + 1] === 'reference'
          ) && (
            ternary.length === 0 ||
            ternary[ternary.length - 1] < data.begin[a]
          ) && (
            'mapclassexpressionmethodglobalparen'.indexOf(data.stack[a]) > -1 || (
              data.types[a - 2] === 'word' && data.stack[a] !== 'switch'
            )
          )
        ) {
          level[a - 1] = -20;
          level.push(-10);
          return;
        }

        if (
          data.stack[a] === 'switch' && (
            ternary.length < 1 ||
            ternary[ternary.length - 1] < data.begin[a]
          )
        ) {

          level[a - 1] = -20;

          if (rules.script.caseSpace === true) {
            level.push(-10);
          } else {
            level.push(indent);
          }

          return;
        }

        if (data.stack[a] === 'object') {
          level[a - 1] = -20;
        } else if (ternary.length > 0) {
          level[a - 1] = indent;
        } else {
          level[a - 1] = -10;
        }

        level.push(-10);
        return;
      }

      if (ctoke === '++' || ctoke === '--') {

        if (ltype === 'number' || ltype === 'reference') {

          level[a - 1] = -20;
          level.push(-10);

        } else if (
          a < b - 1 && (
            data.types[a + 1] === 'number' ||
            data.types[a + 1] === 'reference'
          )
        ) {
          level.push(-20);
        } else {
          level.push(-10);
        }

        return;
      }

      if (ctoke === '+') {

        if (ltype === 'start') {
          level[a - 1] = -20;
        } else {
          level[a - 1] = -10;
        }

        if (rules.wrap < 1 || data.token[data.begin[a]] === 'x(') {
          level.push(-10);
          return;
        }

        const aa = data.token[a + 1];

        if (aa === undefined) {
          level.push(-10);
          return;
        }

        if (data.types[a - 1] === 'operator' || data.types[a - 1] === 'start') {

          if (data.types[a + 1] === 'reference' || aa === '(' || aa === '[') {
            level.push(-20);
            return;
          }

          if (
            Number(aa.slice(1, -1)) > -1 && (
              (/\d/).test(aa.charAt(1)) === true ||
              aa.charAt(1) === '.' ||
              aa.charAt(1) === '-' ||
              aa.charAt(1) === '+'
            )
          ) {

            level.push(-20);
            return;
          }
        }

        return opWrap();
      }

      if (data.types[a - 1] !== 'comment') {

        if (is(ltoke, ch.LPR)) {
          level[a - 1] = -20;
        } else if (
          ctoke === '*' &&
          data.stack[a] === 'object' &&
          data.types[a + 1] === 'reference' && (
            is(ltoke, ch.LCB) ||
            is(ltoke, ch.COM)
          )
        ) {

          level[a - 1] = indent;
        } else if (ctoke !== '?' || ternary.length === 0) {
          level[a - 1] = -10;
        }
      }

      if (
        ctoke.indexOf('=') > -1 &&
        ctoke !== '==' &&
        ctoke !== '===' &&
        ctoke !== '!=' &&
        ctoke !== '!==' &&
        ctoke !== '>=' &&
        ctoke !== '<=' &&
        ctoke !== '=>' &&
        data.stack[a] !== 'method' &&
        data.stack[a] !== 'object'
      ) {

        let c = a + 1;
        let d = 0;
        let e = false;
        let f = NIL;

        if ((
          is(data.token[data.begin[a]], ch.LPR) ||
          data.token[data.begin[a]] === 'x(') &&
          data.token[a + 1] !== 'function'
        ) {
          return;
        }

        do {

          if (data.types[c] === 'start') {

            if (e === true && data.token[c] !== '[') {
              if (assignlist[assignlist.length - 1] === true) {
                assignlist[assignlist.length - 1] = false;
              }

              break;
            }

            d = d + 1;
          }

          if (data.types[c] === 'end') d = d - 1;

          if (d < 0) {

            if (assignlist[assignlist.length - 1] === true) {
              assignlist[assignlist.length - 1] = false;
            }
            break;
          }

          if (d === 0) {

            f = data.token[c];

            if (e === true) {

              if (
                data.types[c] === 'operator' ||
                is(data.token[c], ch.SEM) ||
                data.token[c] === 'x;' ||
                data.token[c] === '?' ||
                data.token[c] === 'var' ||
                data.token[c] === 'let' ||
                data.token[c] === 'const'
              ) {

                if (
                  f !== undefined && (
                    f === '?' || (
                      f.indexOf('=') > -1 &&
                      f !== '==' &&
                      f !== '===' &&
                      f !== '!=' &&
                      f !== '!==' &&
                      f !== '>=' &&
                      f !== '<='
                    )
                  )
                ) {

                  if (assignlist[assignlist.length - 1] === false) {
                    assignlist[assignlist.length - 1] = true;
                  }
                }

                if (
                  (
                    f === ';' ||
                    f === 'x;' ||
                    f === 'var' ||
                    f === 'let' ||
                    f === 'const'
                  ) &&
                  assignlist[assignlist.length - 1] === true
                ) {
                  assignlist[assignlist.length - 1] = false;
                }

                break;
              }

              if (
                assignlist[assignlist.length - 1] === true && (
                  f === 'return' ||
                  f === 'break' ||
                  f === 'continue' ||
                  f === 'throw'
                )
              ) {

                assignlist[assignlist.length - 1] = false;
              }
            }

            if (f === ';' || f === 'x;' || f === ',') e = true;

          }

          c = c + 1;

        } while (c < b);

        level.push(-10);
        return;
      }

      if (
        (
          ctoke === '-' &&
          ltoke === 'return'
        ) ||
        is(ltoke, ch.EQS)
      ) {
        level.push(-20);
        return;
      }

      if (
        ltype === 'operator' &&
        data.types[a + 1] === 'reference' &&
        ltoke !== '--' &&
        ltoke !== '++' &&
        ctoke !== '&&' &&
        ctoke !== '||'
      ) {

        level.push(-20);
        return;
      }

      return opWrap();

    };

    function reference () {

      // beautify_script_level_reference_hoist
      const hoist = () => {

        let func = data.begin[a];

        if (func < 0) {
          parse.scopes.push([ data.token[a], -1 ]);
        } else {

          if (data.stack[func + 1] !== 'function') {
            do {
              func = data.begin[func];
            } while (func > -1 && data.stack[func + 1] !== 'function');
          }

          parse.scopes.push([ data.token[a], func ]);
        }
      };

      if (data.types[a - 1] === 'comment') {

        level[a - 1] = indent;

      } else if (
        ltype === 'end' &&
        ltoke !== ')' && data.token[data.begin[a - 1] - 1] !== ')'
      ) {

        level[a - 1] = -10;

      } else if (
        ltype !== 'separator' &&
        ltype !== 'start' &&
        ltype !== 'end' && ltype.indexOf('template_string') < 0) {

        if (
          ltype === 'word' ||
          ltype === 'operator' ||
          ltype === 'property' ||
          ltype === 'type' ||
          ltype === 'reference'
        ) {
          level[a - 1] = -10;
        } else {
          level[a - 1] = -20;
        }
      }

      if (ltoke === 'var' && data.lexer[a - 1] === lexer) {
        // hoisted references following declaration keyword
        hoist();

      } else if (ltoke === 'function') {

        parse.scopes.push([ data.token[a], a ]);

      } else if (ltoke === 'let' || ltoke === 'const') {

        // not hoisted references following declaration keyword
        parse.scopes.push([ data.token[a], a ]);

      } else if (data.stack[a] === 'arguments') {

        parse.scopes.push([ data.token[a], a ]);
      } else if (is(ltoke, ch.COM)) {

        // references following a comma, must be tested to see if a declaration list
        let index = a;

        do {
          index = index - 1;
        } while (
          index > data.begin[a] &&
          data.token[index] !== 'var' &&
          data.token[index] !== 'let' &&
          data.token[index] !== 'const'
        );

        if (data.token[index] === 'var') {
          hoist();
        } else if (data.token[index] === 'let' || data.token[index] === 'const') {
          parse.scopes.push([ data.token[a], a ]);
        }
      }

      level.push(-10);

    };

    function separator () {

      const ei = (extraindent[extraindent.length - 1] === undefined)
        ? []
        : extraindent[extraindent.length - 1];

      const propertybreak = () => {

        if (rules.script.methodChain > 0) {

          let x = a;
          let y = data.begin[a];

          const z = [ a ];
          const ify = (data.token[y - 1] === 'if');

          do {

            x = x - 1;

            if (data.types[x] === 'end') x = data.begin[x];
            if (data.begin[x] === y) {

              if (
                data.types[x] === 'string' &&
                data.token[x].indexOf('${') === data.token[x].length - 2) {
                break;
              }

              if (data.token[x] === '.') {

                if (level[x - 1] > 0) {
                  level[a - 1] = (ify === true) ? indent + 1 : indent;
                  return;
                }

                z.push(x);

              } else if (
                data.token[x] === ';' ||
                data.token[x] === ',' ||
                data.types[x] === 'operator' || (
                  (
                    data.types[x] === 'word' ||
                    data.types[x] === 'reference'
                  ) && (
                    data.types[x - 1] === 'word' ||
                    data.types[x - 1] === 'reference'
                  )
                )
              ) {
                break;
              }
            }

          } while (x > y);

          if (z.length < rules.script.methodChain) {
            level[a - 1] = -20;
            return;
          }

          x = 0;
          y = z.length;

          do {
            level[z[x] - 1] = (ify === true) ? indent + 1 : indent;
            x = x + 1;
          } while (x < y);

          x = z[z.length - 1] - 1;

          do {

            if (level[x] > -1) level[x] = level[x] + 1;

            x = x + 1;

          } while (x < a);

          indent = (ify === true) ? indent + 2 : indent + 1;
        }

        level[a - 1] = indent;

      };

      if (ctoke === '::') {
        level[a - 1] = -20;
        level.push(-20);
        return;
      }

      if (ctoke === '.') {

        if (
          data.token[data.begin[a]] !== '(' &&
          data.token[data.begin[a]] !== 'x(' &&
          ei.length > 0
        ) {

          if (data.stack[a] === 'object' || data.stack[a] === 'array') {
            destructfix(true, false);
          } else {
            destructfix(false, false);
          }
        }

        if (rules.script.methodChain === 0) {

          // methodchain is 0 so methods and properties should be chained together
          level[a - 1] = -20;

        } else if (rules.script.methodChain < 0) {

          if (data.lines[a] > 0) {
            propertybreak();
          } else {
            level[a - 1] = -20;
          }
        } else {

          // methodchain is greater than 0 and should break
          // methods if the chain reaches this value
          propertybreak();
        }

        level.push(-20);

        return;
      }

      if (ctoke === ',') {

        fixchain();

        if (
          commas[commas.length - 1] === false && (
            data.stack[a] === 'object' ||
            data.stack[a] === 'array' ||
            data.stack[a] === 'paren' ||
            data.stack[a] === 'expression' ||
            data.stack[a] === 'method'
          )
        ) {

          commas[commas.length - 1] = true;

          if (is(data.token[data.begin[a]], ch.LPR)) {

            let aa = a;

            do {

              aa = aa - 1;

              if (
                data.begin[aa] === data.begin[a] &&
                data.token[aa] === '+' && level[aa] > -9
              ) {
                level[aa] = level[aa] + 2;
              }

            } while (aa > data.begin[a]);
          }
        }

        if (data.stack[a] === 'array' && rules.script.arrayFormat === 'indent') {
          level[a - 1] = -20;
          level.push(indent);
          return;
        }

        if (data.stack[a] === 'array' && rules.script.arrayFormat === 'inline') {
          level[a - 1] = -20;
          level.push(-10);
          return;
        }

        if (data.stack[a] === 'object' && rules.script.objectIndent === 'indent') {
          level[a - 1] = -20;
          level.push(indent);
          return;
        }

        if (data.stack[a] === 'object' && rules.script.objectIndent === 'inline') {
          level[a - 1] = -20;
          level.push(-10);
          return;
        }

        if (ei.length > 0) {

          if (ei[ei.length - 1] > -1) endExtraInd();

          level[a - 1] = -20;
          level.push(indent);
          return;
        }

        if (data.token[a - 2] === ':' && data.token[a - 4] === 'where') {
          level[a - 1] = -20;
          level.push(-10);
          return;
        }

        level[a - 1] = -20;

        if (data.types[a + 1] !== 'end') {
          itemcount[itemcount.length - 1] = itemcount[itemcount.length - 1] + 1;
        }

        if (
          (
            is(data.token[data.begin[a]], ch.LPR) ||
            data.token[data.begin[a]] === 'x('
          ) &&
          rules.language !== 'jsx' &&
          data.stack[a] !== 'global' && (
            (
              data.types[a - 1] !== 'string' &&
              data.types[a - 1] !== 'number'
            ) ||
            data.token[a - 2] !== '+' || (
              data.types[a - 1] === 'string' &&
              data.types[a - 1] !== 'number' &&
              is(data.token[a - 2], ch.PLS) &&
              data.types[a - 3] !== 'string' &&
              data.types[a - 3] !== 'number'
            )
          )
        ) {

          level.push(-10);
          return;
        }

        if (
          ltype === 'reference' &&
          data.types[a - 2] === 'word' &&
          'var-let-const-from'.indexOf(data.token[a - 2]) < 0 && (
            data.types[a - 3] === 'end' ||
            data.token[a - 3] === ';'
          )
        ) {

          wordlist[wordlist.length - 1] = true;
          level.push(-10);
          return;
        }

        if (wordlist[wordlist.length - 1] === true || data.stack[a] === 'notation') {
          level.push(-10);
          return;
        }

        if (
          itemcount[itemcount.length - 1] > 3 && (
            data.stack[a] === 'array' ||
            data.stack[a] === 'object'
          )
        ) {

          if (destruct[destruct.length - 1] === true) destructfix(true, true);

          level[a - 1] = -20;

          if (arrbreak[arrbreak.length - 1] === true) {
            level.push(indent);
            return;
          }

          const begin = data.begin[a];
          let c = a;

          do {

            if (data.types[c] === 'end') {
              c = data.begin[c];
            } else {
              if (is(data.token[c], ch.COM) && data.types[c + 1] !== 'comment') {
                level[c] = indent;
              }
            }

            c = c - 1;

          } while (c > begin);

          level[begin] = indent;
          arrbreak[arrbreak.length - 1] = true;

          return;
        }

        if (data.stack[a] === 'object') {

          if (
            destruct[destruct.length - 1] === true &&
            data.types[data.begin[a] - 1] !== 'word' &&
            data.types[data.begin[a] - 1] !== 'reference' &&
            data.token[data.begin[a] - 1] !== '(' &&
            data.token[data.begin[a] - 1] !== 'x('
          ) {

            const bb = data.begin[a];
            let aa = a - 1;

            do {
              if (data.begin[aa] === bb) {

                if (is(data.token[aa], ch.COM)) break;
                if (is(data.token[aa], ch.COL)) {
                  destructfix(true, false);
                  break;
                }
              }

              aa = aa - 1;

            } while (aa > bb);
          }
        }

        if (
          destruct[destruct.length - 1] === false || (
            is(data.token[a - 2], ch.PLS) && (
              ltype === 'string' ||
              ltype === 'number'
            ) &&
            level[a - 2] > 0 && (
              is(ltoke, ch.DQO) ||
              is(ltoke, ch.SQO)
            )
          )
        ) {

          if (data.stack[a] === 'method') {
            if (
              is(data.token[a - 2], ch.PLS) && (
                is(ltoke, ch.DQO) ||
                is(ltoke, ch.SQO)
              ) && (
                data.token[a - 3].charAt(0) === '"' ||
                data.token[a - 3].charAt(0) === "'"
              )
            ) {
              level.push(indent + 2);
              return;
            }

            if (data.token[a - 2] !== '+') {
              level.push(-10);
              return;
            }
          }

          level.push(indent);
          return;
        }

        if (destruct[destruct.length - 1] === true && data.stack[a] !== 'object') {
          level.push(-10);
          return;
        }

        if (
          itemcount[itemcount.length - 1] < 4 && (
            data.stack[a] === 'array' ||
            data.stack[a] === 'object'
          )
        ) {
          level.push(-10);
          return;
        }

        level.push(indent);
        return;
      }

      if (is(ctoke, ch.SEM) || ctoke === 'x;') {

        fixchain();

        if (
          data.token[a + 1] !== undefined &&
          data.types[a + 1].indexOf('attribute') > 0 &&
          data.types[a + 1].indexOf('end') > 0
        ) {
          level[a - 1] = -20;
          level.push(indent - 1);
          return;
        }

        if (
          vindex[vindex.length - 1] > -1 &&
          data.stack[vindex[vindex.length - 1]] !== 'expression'
        ) {

          let aa = a;

          do {

            aa = aa - 1;

            if (is(data.token[aa], ch.SEM)) break;

            if (is(data.token[aa], ch.COM)) {
              indent = indent - 1;
              break;
            }

            if (data.types[aa] === 'end') aa = data.begin[aa];

          } while (aa > 0 && aa > data.begin[a]);
        }

        vindex[vindex.length - 1] = -1;

        endExtraInd();

        if (data.token[data.begin[a] - 1] !== 'for') destructfix(false, false);
        if (ctoke === 'x;') semi = semi + 1;

        wordlist[wordlist.length - 1] = false;
        level[a - 1] = -20;

        if (
          data.begin[a] > 0 &&
          data.token[data.begin[a] - 1] === 'for' &&
          data.stack[a] !== 'for'
        ) {
          level.push(-10);
          return;
        }

        level.push(indent);
        return;
      }

      level.push(-20);
    };

    function start () {

      const deep = data.stack[a + 1];
      const deeper = (a === 0) ? data.stack[a] : data.stack[a - 1];

      if (
        is(ltoke, ch.RPR) || (
          not(ltoke, ch.RSB) && (
            deeper === 'object' ||
            deeper === 'array'
          )
        )
      ) {

        if (
          deep !== 'method' || (
            deep === 'method' &&
            not(data.token[a + 1], ch.RPR) &&
            not(data.token[a + 2], ch.RPR)
          )
        ) {

          if (
            is(ltoke, ch.RPR) && (
              deep !== 'function' ||
             is(data.token[data.begin[data.begin[a - 1] - 1]], ch.LPR) ||
              data.token[data.begin[data.begin[a - 1] - 1]] === 'x('
            )
          ) {

            destructfix(false, false);
          } else if (data.types[a + 1] !== 'end' && data.types[
            a + 2] !== 'end') {
            destructfix(true, false);
          }
        }
      }

      commas.push(false);
      extraindent.push([]);
      assignlist.push(false);
      arrbreak.push(false);
      wordlist.push(false);
      itemcount.push(0);

      if (
        rules.script.neverFlatten === true ||
        deep === 'attribute' ||
        ltype === 'generic' || (
          rules.script.arrayFormat === 'indent' &&
          deep === 'array'
        ) || (
          deep === 'class' &&
          not(ltoke, ch.LPR) &&
          ltoke !== 'x('
        ) || (
          is(ctoke, ch.LSB) &&
          data.token[a + 1] === 'function'
        )
      ) {

        destruct.push(false);

      } else {

        if (deep === 'expression' || deep === 'method') {
          destruct.push(true);

        } else if (
          (
            deep === 'object' ||
            deep === 'class'
          ) && (
            is(ltoke, ch.LPR) ||
            ltoke === 'x(' ||
            ltype === 'word' ||
            ltype === 'reference'
          )
        ) {

          // array or object literal following `return` or `(`
          destruct.push(true);

        } else if (deep === 'array' || is(ctoke, ch.LPR) || ctoke === 'x(') {

          // array, method, paren
          destruct.push(true);

        } else if (
          is(ctoke, ch.LCB) &&
          deep === 'object' &&
          ltype !== 'operator' &&
          ltype !== 'start' &&
          ltype !== 'string' &&
          ltype !== 'number' &&
          deeper !== 'object' &&
          deeper !== 'array' &&
          a > 0
        ) {

          // curly brace not in a list and not assigned
          destruct.push(true);
        } else {

          // not destructured (multiline)
          destruct.push(false);
        }
      }

      if (not(ctoke, ch.LPR) && ctoke !== 'x(' && data.stack[a + 1] !== 'attribute') {
        indent = indent + 1;
      }

      if (is(ctoke, ch.LCB) || ctoke === 'x{') {

        vindex.push(-1);

        if (data.types[a - 1] !== 'comment') {

          if (ltype === 'markup') {

            level[a - 1] = indent;

          } else if (
            rules.script.braceAllman === true &&
            ltype !== 'operator' &&
            ltoke !== 'return'
          ) {

            level[a - 1] = indent - 1;

          } else if (
            data.stack[a + 1] !== 'block' && (
              deep === 'function' ||
              is(ltoke, ch.RPR) ||
              ltoke === 'x)' ||
              is(ltoke, ch.COM) ||
              is(ltoke, ch.RCB) ||
              ltype === 'markup' as any
            )
          ) {

            level[a - 1] = -10;

          } else if (
            is(ltoke, ch.LCB) ||
            ltoke === 'x{' ||
            is(ltoke, ch.LSB) ||
            is(ltoke, ch.RCB) ||
            ltoke === 'x}'
          ) {

            level[a - 1] = indent - 1;
          }
        }

        if (deep === 'object') {

          if (rules.script.objectIndent === 'indent') {
            destruct[destruct.length - 1] = false;
            level.push(indent);
            return;
          }

          if (rules.script.objectIndent === 'inline') {
            destruct[destruct.length - 1] = true;
            level.push(-20);
            return;
          }
        }

        if (deep === 'switch') {

          if (rules.script.noCaseIndent === true) {
            level.push(indent - 1);
            return;
          }

          indent = indent + 1;
          level.push(indent);

          return;
        }

        if (destruct[destruct.length - 1] === true) {
          if (ltype !== 'word' && ltype !== 'reference') {
            level.push(-20);
            return;
          }
        }

        level.push(indent);

        return;
      }

      if (is(ctoke, ch.LPR) || ctoke === 'x(') {

        if (rules.wrap > 0 && is(ctoke, ch.LPR) && data.token[a + 1] !== ')') {
          count.push(1);
        }

        if (is(ltoke, ch.DSH) && (is(data.token[a - 2], ch.LPR) || data.token[a - 2] === 'x(')) {
          level[a - 2] = -20;
        }

        if (
          ltype === 'end' &&
          deeper !== 'if' &&
          deeper !== 'for' &&
          deeper !== 'catch' &&
          deeper !== 'else' &&
          deeper !== 'do' &&
          deeper !== 'try' &&
          deeper !== 'finally' &&
          deeper !== 'catch'
        ) {

          if (data.types[a - 1] === 'comment') {
            level[a - 1] = indent;
          } else {
            level[a - 1] = -20;
          }
        }

        if (ltoke === 'async') {

          level[a - 1] = -10;

        } else if (
          deep === 'method' || (
            data.token[a - 2] === 'function' &&
            ltype === 'reference'
          )
        ) {

          if (
            ltoke === 'import' ||
            ltoke === 'in' ||
            rules.script.functionNameSpace === true
          ) {
            level[a - 1] = -10;

          } else if (
            (
              is(ltoke, ch.RCB) &&
              data.stack[a - 1] === 'function'
            ) ||
            ltype === 'word' ||
            ltype === 'reference' ||
            ltype === 'property'
          ) {

            level[a - 1] = -20;

          } else if (deeper !== 'method' && deep !== 'method') {
            level[a - 1] = indent;
          }
        }

        if (is(ltoke, ch.PLS) && (is(data.token[a - 2], ch.DQO) || is(data.token[a - 2], ch.SQO))) {
          level.push(indent);
          return;
        }

        if (is(ltoke, ch.RCB) || ltoke === 'x}') {

          level.push(-20);
          return;
        }

        if (
          (
            is(ltoke, ch.DSH) && (
              a < 2 || (
                not(data.token[a - 2], ch.RPR) &&
                not(data.token[a - 2], ch.RSB) &&
                data.token[a - 2] !== 'x)' &&
                data.types[a - 2] !== 'reference' &&
                data.types[a - 2] !== 'string' &&
                data.types[a - 2] !== 'number'
              )
            )
          ) || (
            rules.script.functionSpace === false &&
            ltoke === 'function'
          )
        ) {
          level[a - 1] = -20;
        }

        level.push(-20);

        return;
      }

      if (is(ctoke, ch.LSB)) {

        if (is(ltoke, ch.LSB)) commas[commas.length - 2] = true;

        if (
          ltoke === 'return' ||
          ltoke === 'var' ||
          ltoke === 'let' ||
          ltoke === 'const'
        ) {

          level[a - 1] = -10;

        } else if (
          data.types[a - 1] !== 'comment' &&
          data.stack[a - 1] !== 'attribute' && (
            ltype === 'end' ||
            ltype === 'word' ||
            ltype === 'reference'
          )
        ) {

          level[a - 1] = -20;

        } else if (is(ltoke, ch.LSB) || is(ltoke, ch.LCB) || ltoke === 'x{') {
          level[a - 1] = indent - 1;
        }

        if (data.stack[a] === 'attribute') {
          level.push(-20);
          return;
        }

        if (rules.script.arrayFormat === 'indent') {
          destruct[destruct.length - 1] = false;
          level.push(indent);
          return;
        }

        if (rules.script.arrayFormat === 'inline') {
          destruct[destruct.length - 1] = true;
          level.push(-20);
          return;
        }

        if (deep === 'method' || destruct[destruct.length - 1] === true) {
          level.push(-20);
          return;
        }

        let c = a + 1;

        do {

          if (is(data.token[c], ch.RSB)) {
            level.push(-20);
            return;
          }

          if (is(data.token[c], ch.COM)) {
            level.push(indent);
            return;
          }

          c = c + 1;

        } while (c < b);

        level.push(-20);

      }
    };

    function string () {

      if (ctoke.length === 1) {

        level.push(-20);

        if (data.lines[a] === 0) level[a - 1] = -20;

      } else if (ctoke.indexOf('#!/') === 0) {

        level.push(indent);

      } else if (ltype !== 'liquid' && data.types[a + 1] !== 'liquid') {

        level.push(-10);

      }

      if (
        (
          is(ltoke, ch.COM) ||
          ltype === 'start'
        ) && (
          data.stack[a] === 'object' ||
          data.stack[a] === 'array'
        ) &&
        destruct[destruct.length - 1] === false && a > 0
      ) {

        level[a - 1] = indent;
      }

    };

    function template () {

      // HOT PATCH
      //
      // Let's preserve occurances of Liquid tokens contained within
      // JSON strings. This prevents extra spaces being applied.
      //
      if (rules.language !== 'json' && data.types[a - 1] !== 'string') {

        if (ctype === 'liquid_else') {
          level[a - 1] = indent - 1;
          level.push(indent);

        } else if (ctype === 'liquid_start') {

          indent = indent + 1;

          if (data.lines[a - 1] < 1) level[a - 1] = -20;

          // eslint-disable-next-line no-mixed-operators
          if (data.lines[a] > 0 || ltoke.length === 1 && ltype === 'string') {
            level.push(indent);
          } else {
            level.push(-20);
          }

        } else if (ctype === 'liquid_end') {

          indent = indent - 1;

          if (ltype === 'liquid_start' || data.lines[a - 1] < 1) {
            level[a - 1] = -20;
          } else {
            level[a - 1] = indent;
          }

          if (data.lines[a] > 0) {
            level.push(indent);
          } else {
            level.push(-20);
          }

        } else if (ctype === 'liquid') {

          if (data.lines[a] > 0) {
            level.push(indent);
          } else {
            level.push(-20);
          }
        }
      }

    };

    function templateString () {

      if (ctype === 'template_string_start') {
        indent = indent + 1;
        level.push(indent);

      } else if (ctype === 'template_string_else') {
        fixchain();
        level[a - 1] = indent - 1;
        level.push(indent);
      } else {
        fixchain();
        indent = indent - 1;
        level[a - 1] = indent;
        level.push(-10);
      }

      if (
        a > 2 && (
          data.types[a - 2] === 'template_string_else' ||
          data.types[a - 2] === 'template_string_start'
        )
      ) {

        if (rules.script.bracePadding === true) {
          level[a - 2] = -10;
          level[a - 1] = -10;
        } else {
          level[a - 2] = -20;
          level[a - 1] = -20;
        }
      }
    };

    function types () {

      if (
        is(data.token[a - 1], ch.COM) || (
          is(data.token[a - 1], ch.COL) &&
          data.stack[a - 1] !== 'data_type'
        )
      ) {
        level[a - 1] = -10;
      } else {
        level[a - 1] = -20;
      }

      if (data.types[a] === 'type' || data.types[a] === 'type_end') {
        level.push(-10);
      }

      if (data.types[a] === 'type_start') {
        level.push(-20);
      }

    };

    function word () {

      if ((
        is(ltoke, ch.RPR) ||
        ltoke === 'x)'
      ) && data.stack[a] === 'class' && (
        data.token[data.begin[a - 1] - 1] === 'static' ||
        data.token[data.begin[a - 1] - 1] === 'final' ||
        data.token[data.begin[a - 1] - 1] === 'void'
      )) {
        level[a - 1] = -10;
        level[data.begin[a - 1] - 1] = -10;
      }

      if (is(ltoke, ch.RSB)) level[a - 1] = -10;

      // if (is(ltoke, ch.RCB) || ltoke === 'x}') level[a - 1] = indent;

      if (ctoke === 'else' && is(ltoke, ch.RCB)) {

        if (data.token[a - 2] === 'x}') level[a - 3] = level[a - 3] - 1;

        if (rules.script.braceAllman === true || rules.script.elseNewline === true) {
          level[a - 1] = indent;
        } else {
          // level[a - 1] = -20;
        }
      }

      if (ctoke === 'new' && grammar.js.keywords.has(data.token[a + 1])) news = news + 1;

      if (
        ctoke === 'from' &&
        ltype === 'end' &&
        a > 0 && (
          data.token[data.begin[a - 1] - 1] === 'import' ||
          is(data.token[data.begin[a - 1] - 1], ch.COM)
        )
      ) {
        level[a - 1] = -10;
      }

      if (ctoke === 'function') {

        if (
          rules.script.functionSpace === false &&
          a < b - 1 && (
            is(data.token[a + 1], ch.LPR) ||
            data.token[a + 1] === 'x('
          )
        ) {
          level.push(-20);
          return;
        }

        level.push(-10);

        return;
      }

      if (is(ltoke, ch.DSH) && a > 1) {

        if (data.types[a - 2] === 'operator' || is(data.token[a - 2], ch.COM)) {
          level[a - 1] = -20;
        } else if (data.types[a - 2] === 'start') {
          level[a - 2] = -20;
          level[a - 1] = -20;
        }

      } else if ((ctoke === 'while') && (is(ltoke, ch.RCB) || ltoke === 'x}')) {

        // verify if this is a do/while block
        let c = a - 1;
        let d = 0;

        do {

          if (is(data.token[c], ch.RCB) || data.token[c] === 'x}') d = d + 1;
          if (is(data.token[c], ch.LCB) || data.token[c] === 'x{') d = d - 1;
          if (d === 0) {
            if (data.token[c - 1] === 'do') {
              level[a - 1] = -10;
              break;
            }

            level[a - 1] = indent;
            break;
          }

          c = c - 1;
        } while (c > -1);

      } else if (ctoke === 'in' || (
        (
          is(ltoke, ch.RCB) ||
          ltoke === 'x}'
        ) && (
          ctoke === 'catch' || (
            ctoke === 'else' &&
            rules.script.elseNewline === false &&
            rules.script.braceAllman === false
          )
        )
      )) {

        level[a - 1] = -10;

      } else if (ctoke === 'var' || ctoke === 'let' || ctoke === 'const') {

        vindex[vindex.length - 1] = a;

        if (ltype === 'end') level[a - 1] = indent;

        if (data.token[data.begin[a] - 1] !== 'for') {

          let c = a + 1;
          let d = 0;

          do {

            if (data.types[c] === 'end') d = d - 1;
            if (data.types[c] === 'start') d = d + 1;
            if (d < 0 || (d === 0 && (is(data.token[c], ch.SEM) || is(data.token[c], ch.COM)))) break;

            c = c + 1;
          } while (c < b);

          if (is(data.token[c], ch.COM)) indent = indent + 1;

        }

        level.push(-10);
        return;
      }

      if (ltype !== 'word' && data.stack[a] === 'switch' && (
        ctoke === 'default' ||
        ctoke === 'case')) {
        level[a - 1] = indent - 1;
        level.push(-10);
        return;
      }

      if (ctoke === 'catch' && ltoke === '.') {
        level[a - 1] = -20;
        level.push(-20);
        return;
      }

      if (ctoke === 'catch' || ctoke === 'finally') {
        level[a - 1] = -10;
        level.push(-10);
        return;
      }

      if (rules.script.bracePadding === false && a < b - 1 && is(data.token[a + 1], ch.RCB)) {
        level.push(-20);
        return;
      }

      if (data.stack[a] === 'object' && (
        is(ltoke, ch.LCB) ||
        is(ltoke, ch.COM)
      ) && (
        is(data.token[a + 1], ch.LPR) ||
        data.token[a + 1] === 'x('
      )) {
        level.push(-20);
        return;
      }

      if (
        data.types[a - 1] === 'comment' &&
        is(data.token[data.begin[a]], ch.LPR)
      ) {
        level[a - 1] = indent + 1;
      }

      /* -------------------------------------------- */
      /* INLINE RETURNS LOGIC                         */
      /* -------------------------------------------- */

      level.push(-10);
    };

    do {

      if (data.lexer[a] === lexer) {

        ctype = data.types[a];
        ctoke = data.token[a];

        if (ctype === 'comment') {
          comment();
        } else if (ctype === 'regex') {
          level.push(-20);
        } else if (ctype === 'string') {
          string();
        } else if (ctype.indexOf('template_string') === 0) {
          templateString();
        } else if (ctype === 'separator') {
          separator();
        } else if (ctype === 'start') {
          start();
        } else if (ctype === 'end') {
          end();
        } else if (ctype === 'type' || ctype === 'type_start' || ctype === 'type_end') {
          types();
        } else if (ctype === 'operator') {
          operator();
        } else if (ctype === 'word') {
          word();
        } else if (ctype === 'reference') {
          reference();
        } else if (ctype === 'markup') {
          markup();
        } else if (ctype.indexOf('liquid') === 0) {
          template();
        } else if (ctype === 'generic') {

          if (
            not(ltoke, ch.HSH) &&
            ltoke !== 'return' &&
            ltype !== 'operator' &&
            ltoke !== 'public' &&
            ltoke !== 'private' &&
            ltoke !== 'static' &&
            ltoke !== 'final' &&
            ltoke !== 'implements' &&
            ltoke !== 'class' &&
            ltoke !== 'void'
          ) {
            level[a - 1] = -20;
          }

          if (is(data.token[a + 1], ch.LPR) || data.token[a + 1] === 'x(') {
            level.push(-20);
          } else {
            level.push(-10);
          }

        } else {
          level.push(-10);
        }

        if (ctype !== 'comment') {
          ltype = ctype as any;
          ltoke = ctoke;
        }

        if (count.length > 0 && data.token[a] !== ')') {

          if (data.types[a] === 'comment' && count[count.length - 1] > -1) {

            count[count.length - 1] = rules.wrap + 1;

          } else if (
            level[a] > -1 || (
              data.token[a].charAt(0) === '`' &&
              data.token[a].indexOf(NWL) > 0
            )
          ) {

            count[count.length - 1] = -1;

          } else if (count[count.length - 1] > -1) {
            count[count.length - 1] = count[count.length - 1] + data.token[a].length;
            if (level[a] === -10) count[count.length - 1] = count[count.length - 1] + 1;
          }
        }

      } else {

        external();
      }

      a = a + 1;

    } while (a < b);

    return level;

  })();

  const output = (() => {

    const build = [];

    const tab = (() => {

      const tabby = [];
      const chars = rules.indentChar;

      let index = rules.indentSize;

      if (typeof index !== 'number' || index < 1) return NIL;

      do {
        tabby.push(chars);
        index = index - 1;
      } while (index > 0);

      return tabby.join(NIL);

    })();

    const pres = rules.preserveLine + 1;
    const invisibles = [
      'x;',
      'x}',
      'x{',
      'x(',
      'x)'
    ];

    let a = parse.start;

    let lastLevel = rules.indentLevel;

    function nl (tabs: number) {

      const linesout = [];
      const total = (() => {

        if (a === b - 1) return 1;
        if (data.lines[a + 1] - 1 > pres) return pres;
        if (data.lines[a + 1] > 1) return data.lines[a + 1] - 1;

        return 1;

      })();

      let index = 0;

      if (tabs < 0) tabs = 0;

      do {

        linesout.push(parse.crlf);
        index = index + 1;

      } while (index < total);

      if (tabs > 0) {

        index = 0;

        do {
          linesout.push(tab);
          index = index + 1;
        } while (index < tabs);

      }

      return linesout.join(NIL);

    };

    if (rules.script.vertical === true) {

      function vertical (end: number) {

        let longest = 0;
        let complex = 0;

        let aa = end - 1;

        let bb = 0;
        let cc = 0;

        const begin = data.begin[a];
        const list = [];

        do {

          if ((
            data.begin[aa] === begin ||
            is(data.token[aa], ch.RSB) ||
            is(data.token[aa], ch.RPR)
          ) && (
            is(data.token[aa + 1], ch.EQS) || (
              is(data.token[aa + 1], ch.SEM) &&
              data.stack[aa] === 'object'
            )
          )) {

            bb = aa;
            complex = 0;

            do {
              if (data.begin[bb] === begin) {
                if (is(data.token[bb], ch.COL) ||
                  is(data.token[bb], ch.SEM) || data.token[bb] === 'x;' || (
                  levels[bb] > -1 &&
                  data.types[bb] !== 'comment'
                )) {

                  if (is(data.token[bb + 1], ch.DOT)) {
                    complex = complex + (
                      rules.indentSize *
                      rules.indentChar.length
                    );
                  }

                  break;
                }

              } else if (levels[bb] > -1) {

                break;
              }

              if (data.types[bb] !== 'comment') {
                if (levels[bb - 1] === -10) complex = complex + 1;
                complex = data.token[bb].length + complex;
              }

              bb = bb - 1;

            } while (bb > begin);

            cc = bb;

            if (is(data.token[cc], ch.COM) && is(data.token[aa + 1], ch.EQS)) {

              do {

                if (data.types[cc] === 'end') cc = data.begin[cc];
                if (data.begin[cc] === begin) {
                  if (is(data.token[cc], ch.SEM) || data.token[cc] === 'x;') break;
                  if (data.token[cc] === 'var' || data.token[cc] === 'const' || data.token[cc] === 'let') {
                    complex = complex + (rules.indentSize * rules.indentChar.length);
                    break;
                  }
                }

                cc = cc - 1;

              } while (cc > begin);
            }

            if (complex > longest) longest = complex;

            list.push([ aa, complex ]);
            aa = bb;

          } else if (data.types[aa] === 'end') {
            aa = data.begin[aa];
          }

          aa = aa - 1;

        } while (aa > begin);

        aa = list.length;

        if (aa > 0) {

          do {

            aa = aa - 1;
            bb = list[aa][1];

            if (bb < longest) {
              do {
                data.token[list[aa][0]] = data.token[list[aa][0]] + WSP;
                bb = bb + 1;
              } while (bb < longest);
            }

          } while (aa > 0);
        }
      };

      a = b;

      do {

        a = a - 1;

        if (
          data.lexer[a] === 'script' &&
          is(data.token[a], ch.RCB) &&
          not(data.token[a - 1], ch.LCB) &&
          levels[data.begin[a]] > 0) {

          vertical(a);

        } else {
          a = data.begin[a];
        }

      } while (a > 0);
    }

    a = parse.start;

    do {

      if (data.lexer[a] === lexer) {

        // HOT PATCH
        //
        // Improves the indentComment rule by aligning
        // comments to the code they annotate.
        //
        if (data.types[a] === 'comment' && rules.script.commentIndent === true) {

          if (/\n/.test(data.token[a])) {

            const space = data.begin[a] > -1 ? is(data.token[a][2], ch.ARS)
              ? (repeatChar(levels[a], tab) + rules.indentChar)
              : repeatChar(levels[a], tab) : rules.indentChar;

            const comm = data.token[a].split(/\n/);

            let i = 1;

            do {
              comm[i] = space + comm[i].trimStart();
              i = i + 1;
            } while (i < comm.length);

            data.token.splice(a, 1, comm.join(NWL));

          }
        }

        if (invisibles.indexOf(data.token[a]) < 0) {
          if (not(data.token[a], ch.SEM) || rules.script.noSemicolon === false) {
            build.push(data.token[a]);
          } else if (levels[a] < 0 && data.types[a + 1] !== 'comment') {
            build.push(';');
          }
        }

        if (
          a < b - 1 &&
          data.lexer[a + 1] !== lexer &&
          data.begin[a] === data.begin[a + 1] &&
          data.types[a + 1].indexOf('end') < 0 &&
          not(data.token[a], ch.COM)
        ) {

          build.push(WSP);

        } else if (levels[a] > -1) {

          if (
            (
              (levels[a] > -1 && is(data.token[a], ch.LCB)) ||
              (levels[a] > -1 && is(data.token[a + 1], ch.RCB))
            ) &&
            data.lines[a] < 3 &&
            rules.script.braceNewline === true
          ) {

            // console.log(data.token[a]);

            // HOT PATCH
            //
            // We want to skip applying newline in braces when
            // newlines already exist.
            //
            if (data.lines[a + 1] < 3) build.push(nl(0));

          }

          build.push(nl(levels[a]));
          lastLevel = levels[a];

        } else if (levels[a] === -10) {

          build.push(WSP);

          if (data.lexer[a + 1] !== lexer) lastLevel = lastLevel + 1;

        }
      } else {

        if (exidx[a] === a) {

          build.push(data.token[a]);

        } else {

          parse.ender = exidx[a];
          parse.start = a;

          const output = parse.external(lastLevel);

          build.push(output);

          a = parse.iterator;

          if (levels[a] === -10) {
            build.push(WSP);
          } else if (levels[a] > -1) {
            build.push(nl(levels[a]));
          }

          // HOT PATCH
          // Reset indentation level, if not reset to 0 then
          // content will shift on save
          // ex.reset();

        }
      }

      a = a + 1;

    } while (a < b);

    parse.iterator = b - 1;

    // console.log(build);
    // console.log(data);
    return build.join(NIL);

  })();

  assign(rules.script, cache);
  return output;

};
